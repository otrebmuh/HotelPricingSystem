# **Appendix B**

The following table compares the solution generated by the LLM with the ones from the online solution [18].

| Area | Ticketmaster Article | LLM generated solution |
| ----- | ----- | ----- |
| **Service Granularity** | Small set of coarse-grained services (API Gateway, Event, Search, Booking, Payment) | Fine-grained microservices: Auth, User, Event, Search, Inventory, Order, Payment, Ticket, Delivery, Notification, etc. |
| **Seat Reservation Strategy** | Prefers a distributed lock with TTL in Redis to prevent double-booking | Uses optimistic locking in the Inventory DB plus cache invalidation and event sourcing |
| **Peak-Demand Mitigation** | Suggests Server-Sent Events for live seat updates and an optional virtual waiting room built on WebSockets | No explicit real-time push or waiting-room mechanism; relies on caching and eventual consistency via MQ events |
| **Search Synchronisation** | Change Data Capture (CDC) pipeline from PostgreSQL to Elasticsearch to keep the index fresh in near real time | Event Service publishes **“**EventCreated**”** messages; Search Service consumes and indexes, Event-driven rather than CDC |
| **Ticket Generation & Delivery** | Out of scope—design stops once booking is confirmed. | Dedicated Ticket Service and Delivery Service with multi-channel strategy (email / mobile) |
| **Security & Compliance** | Assumes Stripe handles payment security; little depth on broader security. | Explicit PaymentSecurityManager, encryption, circuit-breaker around gateway, JWT/OAuth via external IdP |
| **Data Stores** | Single relational DB (PostgreSQL) plus Redis & Elasticsearch. | Dedicated DB per service, read-replicas, potential sharding and audit logs per domain |

